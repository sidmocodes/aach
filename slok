Perfect! Since you already have a method called `extract_cert_and_key_from_p12` that handles the PKCS12 certificate extraction, we can simplify your SSL implementation significantly. Here's how to update your code to use your existing method:

# Using Your Existing `extract_cert_and_key_from_p12` Method

## **Updated SSL Implementation (Simplified)**

Since you already have the certificate extraction method, here's the simplified version of your SSL code:

```python
import ssl
import tempfile
import os
from pathlib import Path
from typing import Optional, Dict, Any, List
import logging
import aiohttp
import json
from fastapi import HTTPException, Request

from config import settings

logger = logging.getLogger(__name__)

# Module-level variables
_ssl_context: Optional[ssl.SSLContext] = None
_initialized = False

def _initialize_ssl():
    """Initialize SSL context using your existing extract method"""
    global _ssl_context, _initialized
    
    if _initialized:
        return
        
    if not settings.ssl_keystore_path or not settings.ssl_keystore_path.exists():
        logger.warning("No SSL keystore found")
        _initialized = True
        return
        
    try:
        # ✅ Use your existing method instead of the complex implementation
        cert_data, key_data = extract_cert_and_key_from_p12(
            settings.ssl_keystore_path, 
            settings.ssl_keystore_password
        )
        
        # Create SSL context with the extracted data
        _ssl_context = _create_ssl_context(cert_data, key_data)
        _initialized = True
        
        logger.info("SSL authentication initialized successfully using extract_cert_and_key_from_p12")
        
    except Exception as e:
        logger.error(f"SSL initialization failed: {e}")
        _initialized = True

def _create_ssl_context(cert_data: bytes, key_data: bytes) -> Optional[ssl.SSLContext]:
    """Create SSL context with certificate and key data"""
    context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
    
    # Create temporary files for SSL context
    with tempfile.NamedTemporaryFile(mode='wb', delete=False, suffix='.crt') as cert_file:
        cert_file.write(cert_data)
        cert_path = cert_file.name
    
    with tempfile.NamedTemporaryFile(mode='wb', delete=False, suffix='.key') as key_file:
        key_file.write(key_data)
        key_path = key_file.name
    
    try:
        # Load certificate chain
        context.load_cert_chain(cert_path, key_path)
        
        # Simple SSL settings - no verification for internal APIs
        context.verify_mode = ssl.CERT_NONE
        context.check_hostname = False
        context.minimum_version = ssl.TLSVersion.TLSv1_2
        
        return context
    finally:
        # Clean up temporary files
        os.unlink(cert_path)
        os.unlink(key_path)

def get_ssl_context() -> Optional[ssl.SSLContext]:
    """Get SSL context for requests"""
    if not _initialized:
        _initialize_ssl()
    return _ssl_context

def get_auth_headers() -> Dict[str, str]:
    """Get headers for requests"""
    return {
        'User-Agent': 'SSL-Client/1.0'
    }

async def post_form_data(url: str, form_data: dict, files: List[tuple] = None) -> dict:
    """Simple function to POST form data with SSL"""
    ssl_context = get_ssl_context()
    headers = get_auth_headers()
    
    # Remove Content-Type for multipart
    if 'Content-Type' in headers:
        del headers['Content-Type']
    
    # Build form
    form = aiohttp.FormData()
    for key, value in form_data.items():
        if value is not None:  # ✅ Handle None values to prevent Java NPE
            form.add_field(key, str(value))
        else:
            form.add_field(key, "")  # Send empty string instead of None
    
    # Add files if any
    if files:
        for filename, content, content_type in files:
            form.add_field('adjustmentData', content, filename=filename, content_type=content_type)
    
    # Make request
    async with aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=ssl_context)) as session:
        async with session.post(url, data=form, headers=headers) as response:
            if response.status >= 400:
                error_text = await response.text()
                raise Exception(f"Request failed: {response.status} - {error_text}")
            return await response.json()
```

## **What Your `extract_cert_and_key_from_p12` Method Should Return**

Based on the search results, your existing method likely returns the certificate and key in PEM format. Make sure it returns them as bytes:[1][6]

```python
def extract_cert_and_key_from_p12(cert_path: str, password: str) -> tuple[bytes, bytes]:
    """Your existing method - should return (cert_data, key_data) as bytes"""
    # Your existing implementation here
    # Should return:
    # - cert_data: Certificate in PEM format as bytes
    # - key_data: Private key in PEM format as bytes
    return cert_data, key_data
```

## **Usage Example**

```python
# Use it like this for your adjustment API:
form_fields = {
    "valueId": "950866",
    "adjustmentType": "Topside", 
    "adjustmentName": "Test",
    "adjustmentDescription": "Test description",
    "itemClassification": "Incorrect L&F transformation logic",
    "vectorScenario": "LST_SMW_LST_CMB",
    "reportingFrequency": "Daily, Monthly",
    "updateFrequency": "Daily",
    "dailyConsolidation": 0,
    "eucID": "",
    "adjustmentOwner": "",
    "effectiveFrom": "2023-10-19",
    "effectiveTo": "",
    "postingStatusCode": 1,
    "adjustmentPreparer": "Siddharth Mohanty",
    "actionBy": "Siddharth Mohanty"
}

# With Excel file
excel_file = [("data.xlsx", file_content, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")]

response = await post_form_data(
    "https://neo-dev1.ubsdev.net/api/parameter-service/adjustment/950866", 
    form_fields, 
    excel_file
)
```

## **Key Benefits of This Approach**

1. **✅ Uses your existing method** - No need to rewrite certificate extraction logic
2. **✅ Handles None values** - Prevents Java `NullPointerException` by converting None to empty strings
3. **✅ Simple and clean** - Much less code than the previous complex implementation
4. **✅ SSL client certificate authentication** - Still sends your client certificate for authentication
5. **✅ No SSL verification** - Avoids the SSL handshake errors you were getting

This approach leverages your existing `extract_cert_and_key_from_p12` method while providing a simple SSL context for your multipart form POST requests. The key addition is handling None values properly to prevent the Java service from getting null form parameters that cause the `isEmpty()` NullPointerException.

[1] https://stackoverflow.com/questions/77697932/pkcs12-extract-cert-and-key-from-pfx-file
[2] https://www.ssl.com/how-to/export-certificates-private-key-from-pkcs12-file-with-openssl/
[3] https://www.ibm.com/support/pages/extracting-certificate-and-keys-pkcs12-file
[4] https://gist.github.com/sakurai-youhei/a0291e1e7f8130edaa0cf74661f97a62
[5] https://stackoverflow.com/questions/8500475/working-with-openssl-to-extract-information-from-a-pkcs12-certificate/9552237
[6] https://dustinoprea.com/2014/02/18/parsing-p12-certificates-from-python/
[7] https://www.youtube.com/watch?v=reY23gkX4io
[8] https://community.axway.com/s/question/0D53V00000IlxTDSAZ/working-example-of-exporting-private-pkcs12-key-using-certificatesexport-api-and-extract-it-from-the-mixed-part-response
[9] https://anapub.co.ke/journals/jmc/jmc_abstract/2024/jmc_volume_04_issue_02/jmc_volume4_issue2_21.html
[10] https://ieeexplore.ieee.org/document/10665154/
[11] https://ieeexplore.ieee.org/document/10835886/
[12] https://qtanalytics.in/publications/index.php/JoDSC/article/view/215
[13] https://ieeexplore.ieee.org/document/10594130/
[14] https://www.ewadirect.com/proceedings/ace/article/view/15559
[15] https://www.mdpi.com/2079-6382/14/6/549
[16] https://jurnal.ipn.gov.my/wp-content/uploads/2024/12/2.IPNJV14-2-2024-Developing-A-Data-Analytics-Framework-Using-Python-for-Internal-Audit-Functions-of-the-AGD-of-Malaysia.pdf
[17] https://www.spiedigitallibrary.org/conference-proceedings-of-spie/13259/3039595/Research-on-feature-extraction-and-fault-diagnosis-technology-of-rolling/10.1117/12.3039595.full
[18] https://www.spiedigitallibrary.org/conference-proceedings-of-spie/13550/3059209/Research-on-automatic-extraction-technology-of-key-information-for-grid/10.1117/12.3059209.full
[19] https://arxiv.org/pdf/1604.08799.pdf
[20] https://arxiv.org/pdf/2305.08533.pdf
