Thanks ‚Äî this clarification changes the setup significantly.

‚∏ª

‚úÖ You now have:
	‚Ä¢	A single .p12 (PKCS#12) file at:
‚Üí certs/my_certificates/client_certificate.p12
	‚Ä¢	A password to unlock the .p12 file:
‚Üí "Certificates123"

You do not have separate .pem files for:
	‚Ä¢	The client certificate and
	‚Ä¢	The private key

‚∏ª

‚úÖ Objective:

You need to use this .p12 file with password to authenticate outgoing API calls (GET, POST, etc.) from a FastAPI app using mutual TLS (mTLS).

‚∏ª

üîß Solution Plan

Python‚Äôs httpx (and requests) do not directly support .p12. So the steps are:

‚úÖ Step 1: Extract .pem certificate and key in memory or to temp files
	‚Ä¢	Use cryptography + pyOpenSSL or openssl CLI
	‚Ä¢	Protect the password
	‚Ä¢	Use temporary files to avoid leaving sensitive info on disk

‚úÖ Step 2: Use the .pem cert + key with httpx.Client(cert=(cert_path, key_path))

‚∏ª

üß† Option 1: Use cryptography to extract cert + key from .p12 at runtime

Here‚Äôs a complete, secure working setup.

‚∏ª

üìÅ cert_loader.py ‚Äî Extract .p12 to Temp PEMs

# cert_loader.py
import tempfile
import os
from cryptography.hazmat.primitives.serialization import (
    Encoding, PrivateFormat, NoEncryption
)
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.serialization.pkcs12 import load_key_and_certificates

def extract_cert_and_key_from_p12(p12_path: str, password: str):
    """
    Extract cert and private key from .p12 file, write to temp PEM files.
    Returns: (cert_path, key_path)
    """
    with open(p12_path, "rb") as f:
        p12_data = f.read()

    private_key, certificate, additional_certs = load_key_and_certificates(
        p12_data, password.encode(), backend=default_backend()
    )

    # Write cert to temp file
    cert_file = tempfile.NamedTemporaryFile(delete=False, suffix=".pem")
    cert_file.write(certificate.public_bytes(Encoding.PEM))
    if additional_certs:
        for ca in additional_certs:
            cert_file.write(ca.public_bytes(Encoding.PEM))
    cert_file.close()

    # Write private key to temp file
    key_file = tempfile.NamedTemporaryFile(delete=False, suffix=".key")
    key_file.write(
        private_key.private_bytes(
            Encoding.PEM,
            PrivateFormat.TraditionalOpenSSL,
            NoEncryption()
        )
    )
    key_file.close()

    return cert_file.name, key_file.name


‚∏ª

üìÅ ssl_client.py ‚Äî Use This to Call API with Client Auth

# ssl_client.py
import os
import httpx
from cert_loader import extract_cert_and_key_from_p12

P12_PATH = "certs/my_certificates/client_certificate.p12"
P12_PASSWORD = "Certificates123"

def call_ssl_authenticated_api(method, url, headers=None, params=None, json=None):
    cert_path, key_path = extract_cert_and_key_from_p12(P12_PATH, P12_PASSWORD)

    try:
        with httpx.Client(cert=(cert_path, key_path), verify=True) as client:
            response = client.request(
                method=method.upper(),
                url=url,
                headers=headers,
                params=params,
                json=json
            )
            response.raise_for_status()
            return {"status": response.status_code, "data": response.json()}
    except httpx.RequestError as e:
        return {"error": f"Request failed: {str(e)}"}
    except httpx.HTTPStatusError as e:
        return {"error": f"HTTP {e.response.status_code}: {e.response.text}"}
    finally:
        os.remove(cert_path)
        os.remove(key_path)


‚∏ª

üìÅ main.py ‚Äî FastAPI API Proxy with Cert Auth

# main.py
from fastapi import FastAPI, Request, Query
from ssl_client import call_ssl_authenticated_api

app = FastAPI()

@app.api_route("/proxy", methods=["GET", "POST", "PUT", "DELETE", "PATCH"])
async def proxy_api(
    request: Request,
    target_url: str = Query(..., description="URL to call with client cert"),
):
    method = request.method
    headers = dict(request.headers)
    headers.pop("host", None)  # optional: remove FastAPI's internal header
    query_params = dict(request.query_params)
    query_params.pop("target_url", None)
    body = await request.json() if method in {"POST", "PUT", "PATCH"} else None

    result = call_ssl_authenticated_api(
        method=method,
        url=target_url,
        headers=headers,
        params=query_params,
        json=body
    )
    return result


‚∏ª

‚úÖ Example Request

curl -X POST "http://127.0.0.1:8000/proxy?target_url=https://life-ui.com/api/secure" \
  -H "Content-Type: application/json" \
  -d '{"name": "Sid"}'


‚∏ª

üîê Security Considerations
	‚Ä¢	Temp files are auto-deleted; you can add atexit for cleanup in failure cases
	‚Ä¢	Never log passwords
	‚Ä¢	.p12 file should be read-only and ideally encrypted at rest

‚∏ª

‚úÖ What This Solves
	‚Ä¢	You only have .p12 and its password ‚Äî no need for separate .pem files
	‚Ä¢	All FastAPI HTTP methods are supported
	‚Ä¢	Auth certs are handled securely and automatically

‚∏ª

Would you like to:
	‚Ä¢	Cache the extracted PEMs across requests?
	‚Ä¢	Upload the .p12 dynamically (e.g., via FastAPI file upload)?
	‚Ä¢	Log/monitor all outgoing requests for auditing?

Let me know ‚Äî I‚Äôll implement that too.
